# Reusable workflow for mirroring a GitHub branch to Bitbucket
#
# This workflow mirrors a branch from GitHub to Bitbucket and optionally
# waits for the Bitbucket pipeline to complete.
#
# Usage:
#   uses: <owner>/mirror-workflows/.github/workflows/reusable-mirror-branch.yml@main
#
# Common scenarios:
#
# 1. Mirror default branch (main/master) on push:
#    - Trigger: push event to main/master
#    - branch_name: github.ref_name
#
# 2. Mirror PR branch when PR is opened/synchronized:
#    - Trigger: pull_request with types [opened, synchronize, reopened]
#    - branch_name: github.event.pull_request.head.ref
#
# Example caller workflow:
#   on:
#     push:
#       branches: [main, master]
#     pull_request:
#       types: [opened, synchronize, reopened]
#
#   jobs:
#     mirror:
#       if: github.event_name == 'push' || github.event.action != 'closed'
#       uses: <owner>/mirror-workflows/.github/workflows/reusable-mirror-branch.yml@main
#       with:
#         branch_name: ${{ github.event.pull_request.head.ref || github.ref_name }}
#       secrets:
#         BITBUCKET_USERNAME: ${{ secrets.BITBUCKET_USERNAME }}
#         BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
#         BITBUCKET_REPO: ${{ secrets.BITBUCKET_REPO }}
#         BITBUCKET_USER_EMAIL: ${{ secrets.BITBUCKET_USER_EMAIL }}
#
name: Reusable Mirror Branch to Bitbucket

on:
  workflow_call:
    inputs:
      branch_name:
        description: 'Branch name to mirror to Bitbucket'
        required: true
        type: string
      wait_for_pipeline:
        description: 'If true, wait for Bitbucket pipeline to complete'
        required: false
        type: boolean
        default: true
      poll_interval:
        description: 'Seconds between pipeline polling attempts'
        required: false
        type: number
        default: 30
      max_attempts:
        description: 'Maximum polling attempts before timeout'
        required: false
        type: number
        default: 60
    secrets:
      BITBUCKET_USERNAME:
        description: 'Bitbucket username or x-token-auth'
        required: true
      BITBUCKET_API_TOKEN:
        description: 'Bitbucket API token with repo write permissions'
        required: true
      BITBUCKET_REPO:
        description: 'Bitbucket repository path in owner/repo format'
        required: true
      BITBUCKET_USER_EMAIL:
        description: 'Email for git config'
        required: true
    outputs:
      branch_pushed:
        description: 'The branch name that was pushed to Bitbucket'
        value: ${{ jobs.mirror.outputs.branch_pushed }}
      push_occurred:
        description: 'Whether a push actually occurred'
        value: ${{ jobs.mirror.outputs.push_occurred }}
      pipeline_result:
        description: 'Final result of the Bitbucket pipeline'
        value: ${{ jobs.mirror.outputs.pipeline_result }}
      pipeline_url:
        description: 'URL to view the pipeline in Bitbucket'
        value: ${{ jobs.mirror.outputs.pipeline_url }}

jobs:
  mirror:
    runs-on: ubuntu-latest
    outputs:
      branch_pushed: ${{ steps.mirror.outputs.branch_pushed }}
      push_occurred: ${{ steps.mirror.outputs.push_occurred }}
      pipeline_result: ${{ steps.wait-pipeline.outputs.pipeline_result }}
      pipeline_url: ${{ steps.wait-pipeline.outputs.pipeline_url }}

    steps:
      # Step 1: Checkout the calling repository (the one being mirrored)
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch_name }}
          fetch-depth: 0

      # Step 2: Set up Git identity for commits
      - name: Set up Git identity
        env:
          BITBUCKET_USER_EMAIL: ${{ secrets.BITBUCKET_USER_EMAIL }}
        run: |
          git config --global user.name "GitHub Actions Bot - Mirror"
          git config --global user.email "${BITBUCKET_USER_EMAIL}"

      # Step 3: Configure Bitbucket remote with authentication
      - name: Configure Bitbucket Remote
        env:
          BITBUCKET_USERNAME: ${{ secrets.BITBUCKET_USERNAME }}
          BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
          BITBUCKET_REPO: ${{ secrets.BITBUCKET_REPO }}
        run: |
          # Disable credential helpers to prevent interactive prompts
          git config --local credential.helper ""
          git config --global credential.helper ""
          
          # Disable GIT_ASKPASS to prevent interactive credential prompts
          export GIT_ASKPASS=""
          export SSH_ASKPASS=""
          
          # Create Base64 encoded credentials for http.extraHeader (backup method)
          AUTH=$(echo -n "${BITBUCKET_USERNAME}:${BITBUCKET_API_TOKEN}" | base64 -w 0)
          
          # Configure http.extraHeader as a backup authentication method
          git config --local http.https://bitbucket.org/.extraHeader "Authorization: Basic ${AUTH}"
          
          # Remove any existing bitbucket remote first
          git remote remove bitbucket 2>/dev/null || true
          
          # Add remote with credentials embedded in URL (most reliable for automation)
          git remote add bitbucket "https://${BITBUCKET_USERNAME}:${BITBUCKET_API_TOKEN}@bitbucket.org/${BITBUCKET_REPO}.git"
          
          # Validate remote was added
          echo "Validating Bitbucket remote..."
          git remote get-url bitbucket

      # Step 4: Force push branch to Bitbucket
      - name: Mirror to Bitbucket
        id: mirror
        env:
          BRANCH_NAME: ${{ inputs.branch_name }}
          BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
          BITBUCKET_REPO: ${{ secrets.BITBUCKET_REPO }}
        run: |
          # Fetch the branch from Bitbucket to check if it exists
          git fetch bitbucket "${BRANCH_NAME}" || echo "Branch ${BRANCH_NAME} not found on Bitbucket, will create it."
          
          CURRENT_COMMIT=$(git rev-parse HEAD)
          REMOTE_COMMIT=""
          
          # Check if branch exists on Bitbucket and get its commit
          if git ls-remote bitbucket "${BRANCH_NAME}" | grep -q .; then
            REMOTE_COMMIT=$(git ls-remote bitbucket "${BRANCH_NAME}" | awk '{print $1}')
          fi
          
          # Check if bitbucket-pipelines.yml exists in the repo
          if [ -f "bitbucket-pipelines.yml" ]; then
            echo "pipelines_configured=true" >> $GITHUB_OUTPUT
          else
            echo "pipelines_configured=false" >> $GITHUB_OUTPUT
          fi
          
          # Log the push operation
          echo "Force pushing branch '${BRANCH_NAME}' to Bitbucket..."
          echo "GitHub commit: ${CURRENT_COMMIT}"
          if [[ -n "$REMOTE_COMMIT" ]]; then
            echo "Bitbucket commit: ${REMOTE_COMMIT}"
          else
            echo "Bitbucket branch does not exist yet, will be created"
          fi
          
          # Force push to ensure GitHub branch overwrites Bitbucket branch
          if output=$(git push --force bitbucket "HEAD:${BRANCH_NAME}" 2>&1); then
            echo "$output"
            echo "âœ… Branch '${BRANCH_NAME}' force pushed to Bitbucket"
            echo "push_occurred=true" >> $GITHUB_OUTPUT
            echo "branch_pushed=${BRANCH_NAME}" >> $GITHUB_OUTPUT
            
            # If commits matched before push, we need to trigger pipeline via API
            # (Bitbucket won't auto-trigger if no change detected)
            if [[ -n "$REMOTE_COMMIT" && "$CURRENT_COMMIT" == "$REMOTE_COMMIT" ]]; then
              echo "Commits matched - pipeline will be triggered via API"
              echo "trigger_pipeline=true" >> $GITHUB_OUTPUT
            else
              echo "trigger_pipeline=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "$output"
            echo "âŒ Failed to force push branch '${BRANCH_NAME}' to Bitbucket."
            
            # Provide helpful error message for branch protection issues
            if echo "$output" | grep -q "pre-receive hook declined"; then
              echo "::error::â›” PERMISSION DENIED: Bitbucket branch protection blocked the push."
              echo "ðŸ‘‰ SOLUTION: Go to Bitbucket Settings > Branching model > Branch permissions."
            else
              echo "=== Bitbucket Push Error ==="
              echo "GitHub commit: ${CURRENT_COMMIT}"
              if [[ -n "$REMOTE_COMMIT" ]]; then
                echo "Bitbucket commit: ${REMOTE_COMMIT}"
              fi
              echo "::error::Push failed. See logs above."
            fi
            exit 1
          fi

      # Step 5: Trigger Bitbucket Pipeline via API (if same commit already exists)
      - name: Trigger Bitbucket Pipeline (if needed)
        if: steps.mirror.outputs.trigger_pipeline == 'true'
        id: trigger-pipeline
        env:
          BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
          BITBUCKET_REPO: ${{ secrets.BITBUCKET_REPO }}
          BRANCH_NAME: ${{ inputs.branch_name }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          # Extract workspace and repo slug from BITBUCKET_REPO
          WORKSPACE=$(echo "$BITBUCKET_REPO" | cut -d'/' -f1)
          REPO_SLUG=$(echo "$BITBUCKET_REPO" | cut -d'/' -f2)
          
          echo "Triggering pipeline for branch: ${BRANCH_NAME}"
          
          # Try triggering pipeline via branch reference first
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "https://api.bitbucket.org/2.0/repositories/${WORKSPACE}/${REPO_SLUG}/pipelines/" \
            -H "Authorization: Bearer ${BITBUCKET_API_TOKEN}" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -d "{\"target\": {\"ref_type\": \"branch\", \"type\": \"pipeline_ref_target\", \"ref_name\": \"${BRANCH_NAME}\"}}")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n -1)
          
          if [[ "$HTTP_CODE" -ge 200 && "$HTTP_CODE" -lt 300 ]]; then
            UUID=$(echo "$BODY" | grep -o '"uuid": *"[^"]*"' | head -1 | sed 's/"uuid": *"\([^"]*\)"/\1/' | tr -d '{}')
            if [ -n "$UUID" ]; then
              echo "âœ… Pipeline triggered via API (UUID: ${UUID})"
              echo "triggered_pipeline_uuid=${UUID}" >> $GITHUB_OUTPUT
            fi
          else
            echo "âš ï¸ Failed to trigger pipeline via branch ref, trying commit hash..."
            
            # Fallback: try triggering via commit hash
            RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              "https://api.bitbucket.org/2.0/repositories/${WORKSPACE}/${REPO_SLUG}/pipelines/" \
              -H "Authorization: Bearer ${BITBUCKET_API_TOKEN}" \
              -H "Accept: application/json" \
              -H "Content-Type: application/json" \
              -d "{\"target\": {\"commit\": {\"hash\": \"${COMMIT_SHA}\"}, \"type\": \"pipeline_commit_target\"}}")
            
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n -1)
            
            if [[ "$HTTP_CODE" -ge 200 && "$HTTP_CODE" -lt 300 ]]; then
              UUID=$(echo "$BODY" | grep -o '"uuid": *"[^"]*"' | head -1 | sed 's/"uuid": *"\([^"]*\)"/\1/' | tr -d '{}')
              if [ -n "$UUID" ]; then
                echo "âœ… Pipeline triggered via commit hash (UUID: ${UUID})"
                echo "triggered_pipeline_uuid=${UUID}" >> $GITHUB_OUTPUT
              fi
            else
              echo "âŒ Failed to trigger pipeline via API"
              echo "$BODY"
            fi
          fi

      # Step 6: Wait for Bitbucket Pipeline to complete
      - name: Wait for Bitbucket Pipeline
        if: inputs.wait_for_pipeline && steps.mirror.outputs.pipelines_configured == 'true'
        id: wait-pipeline
        env:
          BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
          BITBUCKET_REPO: ${{ secrets.BITBUCKET_REPO }}
          COMMIT_SHA: ${{ github.sha }}
          EXPECTED_PIPELINE_UUID: ${{ steps.mirror.outputs.triggered_pipeline_uuid || steps.trigger-pipeline.outputs.triggered_pipeline_uuid }}
          POLL_INTERVAL: ${{ inputs.poll_interval }}
          MAX_ATTEMPTS: ${{ inputs.max_attempts }}
        run: |
          WORKSPACE=$(echo "$BITBUCKET_REPO" | cut -d'/' -f1)
          REPO_SLUG=$(echo "$BITBUCKET_REPO" | cut -d'/' -f2)
          
          ATTEMPT=0
          FOUND_UUID=""
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            
            # Fetch pipelines for this commit
            RESPONSE=$(curl -s \
              "https://api.bitbucket.org/2.0/repositories/${WORKSPACE}/${REPO_SLUG}/pipelines/?pagelen=50&sort=-created_on&target.commit.hash=${COMMIT_SHA}" \
              -H "Authorization: Bearer ${BITBUCKET_API_TOKEN}" \
              -H "Accept: application/json")
            
            # Find the target pipeline (specific UUID or most recent)
            if [ -n "$EXPECTED_PIPELINE_UUID" ]; then
              PIPELINE=$(echo "$RESPONSE" | jq -r ".values[] | select(.uuid | gsub(\"[{}]\"; \"\") == \"$EXPECTED_PIPELINE_UUID\") | @json" 2>/dev/null | head -1)
            else
              PIPELINE=$(echo "$RESPONSE" | jq -r '.values[0] | @json' 2>/dev/null)
            fi
            
            if [ -n "$PIPELINE" ] && [ "$PIPELINE" != "null" ]; then
              UUID=$(echo "$PIPELINE" | jq -r '.uuid' | tr -d '{}')
              STATE=$(echo "$PIPELINE" | jq -r '.state.name // empty')
              RESULT=$(echo "$PIPELINE" | jq -r '.state.result.name // empty')
              FOUND_UUID="$UUID"
              
              PIPELINE_URL="https://bitbucket.org/${WORKSPACE}/${REPO_SLUG}/addon/pipelines/home#!/results/${UUID}"
              
              # Output pipeline info
              echo "pipeline_uuid=${UUID}" >> $GITHUB_OUTPUT
              echo "pipeline_state=${STATE}" >> $GITHUB_OUTPUT
              echo "pipeline_result=${RESULT}" >> $GITHUB_OUTPUT
              echo "pipeline_url=${PIPELINE_URL}" >> $GITHUB_OUTPUT
              
              echo "[Attempt ${ATTEMPT}/${MAX_ATTEMPTS}] Pipeline ${UUID}: State=${STATE}, Result=${RESULT}"
              
              # Check if pipeline completed
              if [ "$STATE" = "COMPLETED" ]; then
                if [ "$RESULT" = "SUCCESSFUL" ]; then
                  echo "âœ… Bitbucket pipeline succeeded"
                  exit 0
                else
                  echo "âŒ Bitbucket pipeline failed: ${RESULT}"
                  echo "error_message=Pipeline failed with result: ${RESULT}. View: ${PIPELINE_URL}" >> $GITHUB_OUTPUT
                  exit 1
                fi
              fi
            else
              echo "[Attempt ${ATTEMPT}/${MAX_ATTEMPTS}] No pipeline found yet for commit ${COMMIT_SHA}..."
            fi
            
            # Wait before next poll
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              sleep $POLL_INTERVAL
            fi
          done
          
          # Timeout reached
          echo "âŒ Timed out waiting for Bitbucket pipeline"
          if [ -n "$FOUND_UUID" ]; then
            echo "pipeline_url=https://bitbucket.org/${WORKSPACE}/${REPO_SLUG}/addon/pipelines/home#!/results/${FOUND_UUID}" >> $GITHUB_OUTPUT
          fi
          exit 1

      # Step 7: Summarize results (always runs)
      - name: Summarize Bitbucket pipeline result
        if: always()
        env:
          BB_PIPELINE_URL: ${{ steps.wait-pipeline.outputs.pipeline_url }}
          BB_PIPELINE_STATE: ${{ steps.wait-pipeline.outputs.pipeline_state }}
          BB_PIPELINE_RESULT: ${{ steps.wait-pipeline.outputs.pipeline_result }}
          BB_PIPELINE_ERROR: ${{ steps.wait-pipeline.outputs.error_message }}
        run: |
          echo "=== Bitbucket Pipeline Summary ==="
          
          if [ -n "$BB_PIPELINE_URL" ]; then
            echo "Pipeline URL: $BB_PIPELINE_URL"
          else
            echo "Pipeline URL: (not available)"
          fi
          
          if [ -n "$BB_PIPELINE_STATE" ]; then
            echo "Final state: $BB_PIPELINE_STATE"
          fi
          
          if [ -n "$BB_PIPELINE_RESULT" ]; then
            echo "Final result: $BB_PIPELINE_RESULT"
          fi
          
          if [ -n "$BB_PIPELINE_ERROR" ]; then
            echo ""
            echo "Bitbucket pipeline error details:"
            printf '%s\n' "$BB_PIPELINE_ERROR"
          fi


