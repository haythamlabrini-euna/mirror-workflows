# ============================================================================
# DEPRECATED: This workflow is deprecated in favor of the new split workflows.
#
# Please use these purpose-specific workflows instead:
#   - reusable-mirror-branch.yml  - For mirroring branches (push + pipeline)
#   - reusable-delete-branch.yml  - For deleting branches (cleanup)
#
# This file is kept for backward compatibility but will be removed in a future version.
# ============================================================================
#
# Reusable workflow for mirroring GitHub branches to Bitbucket
# 
# This workflow can be called from other repositories using:
#   uses: <owner>/mirror-workflows/.github/workflows/reusable-mirror-to-bitbucket.yml@main
#
# Common usage patterns:
#
# 1. Mirror default branch (main/master) on push:
#    - Trigger: push event to main/master
#    - branch_name: github.ref_name
#    - action_type: push
#
# 2. Mirror PR branch when PR is opened/synchronized:
#    - Trigger: pull_request with types [opened, synchronize, reopened]
#    - branch_name: github.event.pull_request.head.ref
#    - action_type: push
#
# 3. Delete PR branch when PR is closed (not merged):
#    - Trigger: pull_request with type closed and merged == false
#    - branch_name: github.event.pull_request.head.ref
#    - action_type: delete
#    - allow_branch_deletion: true (or false to skip deletion)
#
# 4. Delete PR branch when PR is merged:
#    - Trigger: pull_request with type closed and merged == true
#    - Note: The merge creates a commit on main/master, which triggers a push event
#    - The push event handles mirroring the default branch to Bitbucket
#    - This workflow call handles cleanup by deleting the PR branch
#    - branch_name: github.event.pull_request.head.ref
#    - action_type: delete
#    - allow_branch_deletion: true
#
# Example usage in your repository's workflow file:
#   jobs:
#     mirror:
#       uses: <owner>/mirror-workflows/.github/workflows/reusable-mirror-to-bitbucket.yml@main
#       with:
#         branch_name: ${{ github.event.pull_request.head.ref || github.ref_name }}
#         action_type: ${{ github.event.action == 'closed' && 'delete' || 'push' }}
#         bitbucket_repo: ${{ secrets.BITBUCKET_REPO }}
#       secrets:
#         BITBUCKET_USERNAME: ${{ secrets.BITBUCKET_USERNAME }}
#         BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
#         BITBUCKET_USER_EMAIL: ${{ secrets.BITBUCKET_USER_EMAIL }}
#
# Branch Name Resolution:
#   The workflow automatically determines the correct branch name using this priority:
#   1. Push events: Uses github.ref_name (ensures main/master on PR merge)
#   2. Merged PRs: Uses github.event.pull_request.base.ref (main/master)
#   3. Fallback: Uses the branch_name input parameter
#   This ensures that when PRs are merged, the main/master branch is mirrored,
#   not the PR branch.
#
name: Reusable Mirror to Bitbucket

on:
  # Allow this workflow to be called from other repositories
  workflow_call:
    inputs:
      branch_name:
        description: 'Branch name to push or delete'
        required: true
        type: string
      action_type:
        description: 'Action to perform: "push" to mirror the branch, or "delete" to delete the branch. Use "delete" for PR cleanup (both merged and closed PRs).'
        required: false
        type: string
        default: 'push'
      force_trigger:
        description: 'If true, always push even if commit already exists'
        required: false
        type: boolean
        default: false
      allow_branch_deletion:
        description: 'If false, skip deleting branches on Bitbucket. Set to false to prevent branch deletion even when action_type is "delete". Useful for controlling cleanup behavior.'
        required: false
        type: boolean
        default: true
      wait_for_pipeline:
        description: 'If true, wait for Bitbucket pipeline to complete'
        required: false
        type: boolean
        default: true
      poll_interval:
        description: 'Seconds between pipeline polling attempts'
        required: false
        type: number
        default: 30
      max_attempts:
        description: 'Maximum polling attempts before timeout'
        required: false
        type: number
        default: 60
      # Repository owner/name for this workflow repo (needed for action references)
      workflow_repo:
        description: 'The owner/name of the mirror-workflows repository (e.g., myorg/mirror-workflows)'
        required: false
        type: string
        default: ''
      workflow_ref:
        description: 'The ref (branch/tag) of the mirror-workflows repository to use'
        required: false
        type: string
        default: 'main'
      bitbucket_repo:
        description: 'Bitbucket repository path in owner/repo format'
        required: true
        type: string
    secrets:
      BITBUCKET_USERNAME:
        description: 'Bitbucket username or x-token-auth'
        required: true
      BITBUCKET_API_TOKEN:
        description: 'Bitbucket API token with repo write permissions'
        required: true
      BITBUCKET_USER_EMAIL:
        description: 'Email for git config'
        required: true
    outputs:
      branch_pushed:
        description: 'The branch name that was pushed to Bitbucket'
        value: ${{ jobs.mirror.outputs.branch_pushed }}
      push_occurred:
        description: 'Whether a push actually occurred'
        value: ${{ jobs.mirror.outputs.push_occurred }}
      pipeline_result:
        description: 'Final result of the Bitbucket pipeline'
        value: ${{ jobs.mirror.outputs.pipeline_result }}
      pipeline_url:
        description: 'URL to view the pipeline in Bitbucket'
        value: ${{ jobs.mirror.outputs.pipeline_url }}

jobs:
  mirror:
    runs-on: ubuntu-latest
    outputs:
      branch_pushed: ${{ steps.mirror.outputs.branch_pushed }}
      push_occurred: ${{ steps.mirror.outputs.push_occurred }}
      pipeline_result: ${{ steps.wait-pipeline.outputs.pipeline_result }}
      pipeline_url: ${{ steps.wait-pipeline.outputs.pipeline_url }}

    steps:
      # Checkout the calling repository (the one being mirrored)
      # Priority: push events -> merged PR base branch -> input parameter
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # For push events (including PR merges): use github.ref_name (main/master)
          # For merged PRs: use base branch (main/master)
          # Otherwise: use input parameter (PR branch or fallback)
          ref: ${{ github.event_name == 'push' && github.ref_name || (github.event_name == 'pull_request' && github.event.pull_request.merged && github.event.pull_request.base.ref) || inputs.branch_name }}
          fetch-depth: 0

      - name: Set up Git identity
        env:
          BITBUCKET_USER_EMAIL: ${{ secrets.BITBUCKET_USER_EMAIL }}
        run: |
          git config --global user.name "GitHub Actions Bot - Mirror"
          git config --global user.email "${BITBUCKET_USER_EMAIL}"

      # Configure Bitbucket remote and mirror the branch
      # This is inlined here since composite actions can't be referenced dynamically
      - name: Configure Bitbucket Remote
        env:
          BITBUCKET_USERNAME: ${{ secrets.BITBUCKET_USERNAME }}
          BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
          BITBUCKET_REPO: ${{ inputs.bitbucket_repo }}
        run: |
          # Disable credential helpers to prevent interactive prompts
          # This ensures Git uses our configured authentication instead of prompting
          git config --local credential.helper ""
          git config --global credential.helper ""
          
          # Disable GIT_ASKPASS to prevent interactive credential prompts
          # Setting it to empty string prevents Git from trying to prompt
          export GIT_ASKPASS=""
          export SSH_ASKPASS=""
          
          # Create Base64 encoded credentials for http.extraHeader (backup method)
          # Use -w 0 to disable line wrapping
          AUTH=$(echo -n "${BITBUCKET_USERNAME}:${BITBUCKET_API_TOKEN}" | base64 -w 0)
          
          # Configure http.extraHeader as a backup authentication method
          git config --local http.https://bitbucket.org/.extraHeader "Authorization: Basic ${AUTH}"
          
          # Remove any existing bitbucket remote first
          git remote remove bitbucket 2>/dev/null || true
          
          # Add remote with credentials embedded in URL (most reliable for automation)
          # Format: https://username:token@bitbucket.org/workspace/repo.git
          # This is the most reliable method for automated environments
          git remote add bitbucket "https://${BITBUCKET_USERNAME}:${BITBUCKET_API_TOKEN}@bitbucket.org/${BITBUCKET_REPO}.git"
          
          # Validate remote was added (URL will show credentials, which is expected)
          echo "Validating Bitbucket remote..."
          git remote get-url bitbucket

      # Delete branch from Bitbucket
      # Used for PR cleanup: when PR is closed (merged or not merged)
      # When PR is merged, the merge commit triggers a push event on main/master
      # That push event handles mirroring the default branch to Bitbucket
      # This step handles cleanup by deleting the PR branch
      - name: Delete Branch from Bitbucket
        if: inputs.action_type == 'delete'
        id: delete-branch
        env:
          # For push events: use github.ref_name
          # For merged PRs: use base branch
          # Otherwise: use input parameter
          BRANCH_NAME: ${{ github.event_name == 'push' && github.ref_name || (github.event_name == 'pull_request' && github.event.pull_request.merged && github.event.pull_request.base.ref) || inputs.branch_name }}
          ALLOW_BRANCH_DELETION: ${{ inputs.allow_branch_deletion }}
        run: |
          if [[ "$ALLOW_BRANCH_DELETION" == "false" ]]; then
            echo "â„¹ï¸ Skipping deletion of Bitbucket branch '${BRANCH_NAME}' because ALLOW_BRANCH_DELETION is false."
            echo "push_occurred=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          git fetch bitbucket --all
          
          # Check if branch exists
          if git ls-remote --heads bitbucket "${BRANCH_NAME}" | grep -q .; then
            git push bitbucket ":${BRANCH_NAME}"
            echo "âœ… Branch '${BRANCH_NAME}' deleted from Bitbucket"
            echo "push_occurred=true" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸ Branch '${BRANCH_NAME}' does not exist on Bitbucket"
            echo "push_occurred=false" >> $GITHUB_OUTPUT
          fi

      # Mirror branch to Bitbucket
      # Used for: default branch pushes, PR branch mirroring on open/synchronize
      # When PR is merged, the merge commit on main/master triggers a separate push event
      # That push event will mirror the default branch, not this PR branch
      - name: Mirror to Bitbucket
        if: inputs.action_type != 'delete'
        id: mirror
        env:
          # For push events: use github.ref_name (main/master)
          # For merged PRs: use base branch (main/master)
          # Otherwise: use input parameter (PR branch or fallback)
          BRANCH_NAME: ${{ github.event_name == 'push' && github.ref_name || (github.event_name == 'pull_request' && github.event.pull_request.merged && github.event.pull_request.base.ref) || inputs.branch_name }}
          BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
          BITBUCKET_REPO: ${{ inputs.bitbucket_repo }}
        run: |
          # Fetch the branch from Bitbucket
          git fetch bitbucket "${BRANCH_NAME}" || echo "Branch ${BRANCH_NAME} not found on Bitbucket, will create it."
          
          CURRENT_COMMIT=$(git rev-parse HEAD)
          REMOTE_COMMIT=""
          
          if git ls-remote bitbucket "${BRANCH_NAME}" | grep -q .; then
            REMOTE_COMMIT=$(git ls-remote bitbucket "${BRANCH_NAME}" | awk '{print $1}')
          fi
          
          # Check if bitbucket-pipelines.yml exists
          if [ -f "bitbucket-pipelines.yml" ]; then
            echo "pipelines_configured=true" >> $GITHUB_OUTPUT
          else
            echo "pipelines_configured=false" >> $GITHUB_OUTPUT
          fi
          
          # Always force push to ensure GitHub branch overwrites Bitbucket branch
          echo "Force pushing branch '${BRANCH_NAME}' to Bitbucket..."
          echo "GitHub commit: ${CURRENT_COMMIT}"
          if [[ -n "$REMOTE_COMMIT" ]]; then
            echo "Bitbucket commit: ${REMOTE_COMMIT}"
          else
            echo "Bitbucket branch does not exist yet, will be created"
          fi
          
          # Always use --force to overwrite any divergent history on Bitbucket
          if output=$(git push --force bitbucket "HEAD:${BRANCH_NAME}" 2>&1); then
            echo "$output"
            echo "âœ… Branch '${BRANCH_NAME}' force pushed to Bitbucket"
            echo "push_occurred=true" >> $GITHUB_OUTPUT
            echo "branch_pushed=${BRANCH_NAME}" >> $GITHUB_OUTPUT
            
            # If commits matched before push, trigger pipeline via API instead
            if [[ -n "$REMOTE_COMMIT" && "$CURRENT_COMMIT" == "$REMOTE_COMMIT" ]]; then
              echo "Commits matched - pipeline will be triggered via API"
              echo "trigger_pipeline=true" >> $GITHUB_OUTPUT
            else
              echo "trigger_pipeline=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "$output"
            echo "âŒ Failed to force push branch '${BRANCH_NAME}' to Bitbucket."
            
            if echo "$output" | grep -q "pre-receive hook declined"; then
              echo "::error::â›” PERMISSION DENIED: Bitbucket branch protection blocked the push."
              echo "ðŸ‘‰ SOLUTION: Go to Bitbucket Settings > Branching model > Branch permissions."
            else
              echo "=== Bitbucket Push Error ==="
              echo "GitHub commit: ${CURRENT_COMMIT}"
              if [[ -n "$REMOTE_COMMIT" ]]; then
                echo "Bitbucket commit: ${REMOTE_COMMIT}"
              fi
              echo "::error::Push failed. See logs above."
            fi
            exit 1
          fi

      - name: Trigger Bitbucket Pipeline (if needed)
        if: inputs.action_type != 'delete' && steps.mirror.outputs.trigger_pipeline == 'true'
        id: trigger-pipeline
        env:
          BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
          BITBUCKET_REPO: ${{ inputs.bitbucket_repo }}
          # For push events: use github.ref_name
          # For merged PRs: use base branch
          # Otherwise: use input parameter
          BRANCH_NAME: ${{ github.event_name == 'push' && github.ref_name || (github.event_name == 'pull_request' && github.event.pull_request.merged && github.event.pull_request.base.ref) || inputs.branch_name }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          # Extract workspace and repo slug
          WORKSPACE=$(echo "$BITBUCKET_REPO" | cut -d'/' -f1)
          REPO_SLUG=$(echo "$BITBUCKET_REPO" | cut -d'/' -f2)
          
          echo "Triggering pipeline for branch: ${BRANCH_NAME}"
          
          # Trigger pipeline via API
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "https://api.bitbucket.org/2.0/repositories/${WORKSPACE}/${REPO_SLUG}/pipelines/" \
            -H "Authorization: Bearer ${BITBUCKET_API_TOKEN}" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -d "{\"target\": {\"ref_type\": \"branch\", \"type\": \"pipeline_ref_target\", \"ref_name\": \"${BRANCH_NAME}\"}}")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n -1)
          
          if [[ "$HTTP_CODE" -ge 200 && "$HTTP_CODE" -lt 300 ]]; then
            UUID=$(echo "$BODY" | grep -o '"uuid": *"[^"]*"' | head -1 | sed 's/"uuid": *"\([^"]*\)"/\1/' | tr -d '{}')
            if [ -n "$UUID" ]; then
              echo "âœ… Pipeline triggered via API (UUID: ${UUID})"
              echo "triggered_pipeline_uuid=${UUID}" >> $GITHUB_OUTPUT
            fi
          else
            echo "âš ï¸ Failed to trigger pipeline via branch ref, trying commit hash..."
            
            RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              "https://api.bitbucket.org/2.0/repositories/${WORKSPACE}/${REPO_SLUG}/pipelines/" \
              -H "Authorization: Bearer ${BITBUCKET_API_TOKEN}" \
              -H "Accept: application/json" \
              -H "Content-Type: application/json" \
              -d "{\"target\": {\"commit\": {\"hash\": \"${COMMIT_SHA}\"}, \"type\": \"pipeline_commit_target\"}}")
            
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n -1)
            
            if [[ "$HTTP_CODE" -ge 200 && "$HTTP_CODE" -lt 300 ]]; then
              UUID=$(echo "$BODY" | grep -o '"uuid": *"[^"]*"' | head -1 | sed 's/"uuid": *"\([^"]*\)"/\1/' | tr -d '{}')
              if [ -n "$UUID" ]; then
                echo "âœ… Pipeline triggered via commit hash (UUID: ${UUID})"
                echo "triggered_pipeline_uuid=${UUID}" >> $GITHUB_OUTPUT
              fi
            else
              echo "âŒ Failed to trigger pipeline via API"
              echo "$BODY"
            fi
          fi

      - name: Wait for Bitbucket Pipeline
        if: inputs.action_type != 'delete' && inputs.wait_for_pipeline && steps.mirror.outputs.pipelines_configured == 'true'
        id: wait-pipeline
        env:
          BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
          BITBUCKET_REPO: ${{ inputs.bitbucket_repo }}
          COMMIT_SHA: ${{ github.sha }}
          EXPECTED_PIPELINE_UUID: ${{ steps.mirror.outputs.triggered_pipeline_uuid || steps.trigger-pipeline.outputs.triggered_pipeline_uuid }}
          POLL_INTERVAL: ${{ inputs.poll_interval }}
          MAX_ATTEMPTS: ${{ inputs.max_attempts }}
        run: |
          WORKSPACE=$(echo "$BITBUCKET_REPO" | cut -d'/' -f1)
          REPO_SLUG=$(echo "$BITBUCKET_REPO" | cut -d'/' -f2)
          
          ATTEMPT=0
          FOUND_UUID=""
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            
            # Fetch pipelines for this commit
            RESPONSE=$(curl -s \
              "https://api.bitbucket.org/2.0/repositories/${WORKSPACE}/${REPO_SLUG}/pipelines/?pagelen=50&sort=-created_on&target.commit.hash=${COMMIT_SHA}" \
              -H "Authorization: Bearer ${BITBUCKET_API_TOKEN}" \
              -H "Accept: application/json")
            
            # Find the target pipeline
            if [ -n "$EXPECTED_PIPELINE_UUID" ]; then
              PIPELINE=$(echo "$RESPONSE" | jq -r ".values[] | select(.uuid | gsub(\"[{}]\"; \"\") == \"$EXPECTED_PIPELINE_UUID\") | @json" 2>/dev/null | head -1)
            else
              PIPELINE=$(echo "$RESPONSE" | jq -r '.values[0] | @json' 2>/dev/null)
            fi
            
            if [ -n "$PIPELINE" ] && [ "$PIPELINE" != "null" ]; then
              UUID=$(echo "$PIPELINE" | jq -r '.uuid' | tr -d '{}')
              STATE=$(echo "$PIPELINE" | jq -r '.state.name // empty')
              RESULT=$(echo "$PIPELINE" | jq -r '.state.result.name // empty')
              FOUND_UUID="$UUID"
              
              PIPELINE_URL="https://bitbucket.org/${WORKSPACE}/${REPO_SLUG}/addon/pipelines/home#!/results/${UUID}"
              
              echo "pipeline_uuid=${UUID}" >> $GITHUB_OUTPUT
              echo "pipeline_state=${STATE}" >> $GITHUB_OUTPUT
              echo "pipeline_result=${RESULT}" >> $GITHUB_OUTPUT
              echo "pipeline_url=${PIPELINE_URL}" >> $GITHUB_OUTPUT
              
              echo "[Attempt ${ATTEMPT}/${MAX_ATTEMPTS}] Pipeline ${UUID}: State=${STATE}, Result=${RESULT}"
              
              if [ "$STATE" = "COMPLETED" ]; then
                if [ "$RESULT" = "SUCCESSFUL" ]; then
                  echo "âœ… Bitbucket pipeline succeeded"
                  exit 0
                else
                  echo "âŒ Bitbucket pipeline failed: ${RESULT}"
                  echo "error_message=Pipeline failed with result: ${RESULT}. View: ${PIPELINE_URL}" >> $GITHUB_OUTPUT
                  exit 1
                fi
              fi
            else
              echo "[Attempt ${ATTEMPT}/${MAX_ATTEMPTS}] No pipeline found yet for commit ${COMMIT_SHA}..."
            fi
            
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              sleep $POLL_INTERVAL
            fi
          done
          
          echo "âŒ Timed out waiting for Bitbucket pipeline"
          if [ -n "$FOUND_UUID" ]; then
            echo "pipeline_url=https://bitbucket.org/${WORKSPACE}/${REPO_SLUG}/addon/pipelines/home#!/results/${FOUND_UUID}" >> $GITHUB_OUTPUT
          fi
          exit 1

      - name: Summarize Bitbucket pipeline result
        if: always()
        env:
          BB_PIPELINE_URL: ${{ steps.wait-pipeline.outputs.pipeline_url }}
          BB_PIPELINE_STATE: ${{ steps.wait-pipeline.outputs.pipeline_state }}
          BB_PIPELINE_RESULT: ${{ steps.wait-pipeline.outputs.pipeline_result }}
          BB_PIPELINE_ERROR: ${{ steps.wait-pipeline.outputs.error_message }}
        run: |
          echo "=== Bitbucket Pipeline Summary ==="
          
          if [ -n "$BB_PIPELINE_URL" ]; then
            echo "Pipeline URL: $BB_PIPELINE_URL"
          else
            echo "Pipeline URL: (not available)"
          fi
          
          if [ -n "$BB_PIPELINE_STATE" ]; then
            echo "Final state: $BB_PIPELINE_STATE"
          fi
          
          if [ -n "$BB_PIPELINE_RESULT" ]; then
            echo "Final result: $BB_PIPELINE_RESULT"
          fi
          
          if [ -n "$BB_PIPELINE_ERROR" ]; then
            echo ""
            echo "Bitbucket pipeline error details:"
            printf '%s\n' "$BB_PIPELINE_ERROR"
          fi

