# Reusable workflow for mirroring GitHub branches to Bitbucket
# 
# This workflow can be called from other repositories using:
#   uses: <owner>/mirror-workflows/.github/workflows/reusable-mirror-to-bitbucket.yml@main
#
# Example usage in your repository's workflow file:
#   jobs:
#     mirror:
#       uses: <owner>/mirror-workflows/.github/workflows/reusable-mirror-to-bitbucket.yml@main
#       with:
#         branch_name: ${{ github.ref_name }}
#         action_type: push
#       secrets:
#         BITBUCKET_USERNAME: ${{ secrets.BITBUCKET_USERNAME }}
#         BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
#         BITBUCKET_REPO: ${{ secrets.BITBUCKET_REPO }}
#         BITBUCKET_USER_EMAIL: ${{ secrets.BITBUCKET_USER_EMAIL }}
#
name: Reusable Mirror to Bitbucket

on:
  # Allow this workflow to be called from other repositories
  workflow_call:
    inputs:
      branch_name:
        description: 'Branch name to push or delete'
        required: true
        type: string
      action_type:
        description: 'Action to perform: "push" to mirror the branch, or "delete" to delete the branch'
        required: false
        type: string
        default: 'push'
      force_trigger:
        description: 'If true, always push even if commit already exists'
        required: false
        type: boolean
        default: false
      allow_branch_deletion:
        description: 'If false, skip deleting branches on Bitbucket'
        required: false
        type: boolean
        default: true
      wait_for_pipeline:
        description: 'If true, wait for Bitbucket pipeline to complete'
        required: false
        type: boolean
        default: true
      poll_interval:
        description: 'Seconds between pipeline polling attempts'
        required: false
        type: number
        default: 30
      max_attempts:
        description: 'Maximum polling attempts before timeout'
        required: false
        type: number
        default: 60
      # Repository owner/name for this workflow repo (needed for action references)
      workflow_repo:
        description: 'The owner/name of the mirror-workflows repository (e.g., myorg/mirror-workflows)'
        required: false
        type: string
        default: ''
      workflow_ref:
        description: 'The ref (branch/tag) of the mirror-workflows repository to use'
        required: false
        type: string
        default: 'main'
    secrets:
      BITBUCKET_USERNAME:
        description: 'Bitbucket username or x-token-auth'
        required: true
      BITBUCKET_API_TOKEN:
        description: 'Bitbucket API token with repo write permissions'
        required: true
      BITBUCKET_REPO:
        description: 'Bitbucket repository path in owner/repo format'
        required: true
      BITBUCKET_USER_EMAIL:
        description: 'Email for git config'
        required: true
    outputs:
      branch_pushed:
        description: 'The branch name that was pushed to Bitbucket'
        value: ${{ jobs.mirror.outputs.branch_pushed }}
      push_occurred:
        description: 'Whether a push actually occurred'
        value: ${{ jobs.mirror.outputs.push_occurred }}
      pipeline_result:
        description: 'Final result of the Bitbucket pipeline'
        value: ${{ jobs.mirror.outputs.pipeline_result }}
      pipeline_url:
        description: 'URL to view the pipeline in Bitbucket'
        value: ${{ jobs.mirror.outputs.pipeline_url }}

jobs:
  mirror:
    runs-on: ubuntu-latest
    outputs:
      branch_pushed: ${{ steps.mirror.outputs.branch_pushed }}
      push_occurred: ${{ steps.mirror.outputs.push_occurred }}
      pipeline_result: ${{ steps.wait-pipeline.outputs.pipeline_result }}
      pipeline_url: ${{ steps.wait-pipeline.outputs.pipeline_url }}

    steps:
      # Checkout the calling repository (the one being mirrored)
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch_name }}
          fetch-depth: 0

      - name: Set up Git identity
        env:
          BITBUCKET_USER_EMAIL: ${{ secrets.BITBUCKET_USER_EMAIL }}
        run: |
          git config --global user.name "GitHub Actions Bot - Mirror"
          git config --global user.email "${BITBUCKET_USER_EMAIL}"

      # Configure Bitbucket remote and mirror the branch
      # This is inlined here since composite actions can't be referenced dynamically
      - name: Configure Bitbucket Remote
        env:
          BITBUCKET_USERNAME: ${{ secrets.BITBUCKET_USERNAME }}
          BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
          BITBUCKET_REPO: ${{ secrets.BITBUCKET_REPO }}
        run: |
          # Create Base64 encoded credentials (disable line wrapping)
          AUTH=$(echo -n "${BITBUCKET_USERNAME}:${BITBUCKET_API_TOKEN}" | base64 -w 0)
          
          # Configure http.extraHeader for authentication
          git config --local http.https://bitbucket.org/.extraHeader "Authorization: Basic ${AUTH}"
          
          # Add Bitbucket remote (remove if exists first)
          git remote remove bitbucket 2>/dev/null || true
          git remote add bitbucket "https://bitbucket.org/${BITBUCKET_REPO}.git"
          
          # Validate remote was added
          echo "Validating Bitbucket remote..."
          git remote get-url bitbucket

      - name: Delete Branch from Bitbucket
        if: inputs.action_type == 'delete'
        id: delete-branch
        env:
          BRANCH_NAME: ${{ inputs.branch_name }}
          ALLOW_BRANCH_DELETION: ${{ inputs.allow_branch_deletion }}
        run: |
          if [[ "$ALLOW_BRANCH_DELETION" == "false" ]]; then
            echo "â„¹ï¸ Skipping deletion of Bitbucket branch '${BRANCH_NAME}' because ALLOW_BRANCH_DELETION is false."
            echo "push_occurred=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          git fetch bitbucket --all
          
          # Check if branch exists
          if git ls-remote --heads bitbucket "${BRANCH_NAME}" | grep -q .; then
            git push bitbucket ":${BRANCH_NAME}"
            echo "âœ… Branch '${BRANCH_NAME}' deleted from Bitbucket"
            echo "push_occurred=true" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸ Branch '${BRANCH_NAME}' does not exist on Bitbucket"
            echo "push_occurred=false" >> $GITHUB_OUTPUT
          fi

      - name: Mirror to Bitbucket
        if: inputs.action_type != 'delete'
        id: mirror
        env:
          BRANCH_NAME: ${{ inputs.branch_name }}
          FORCE_TRIGGER: ${{ inputs.force_trigger }}
          BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
          BITBUCKET_REPO: ${{ secrets.BITBUCKET_REPO }}
        run: |
          # Fetch the branch from Bitbucket
          git fetch bitbucket "${BRANCH_NAME}" || echo "Branch ${BRANCH_NAME} not found on Bitbucket, will create it."
          
          CURRENT_COMMIT=$(git rev-parse HEAD)
          REMOTE_COMMIT=""
          
          if git ls-remote bitbucket "${BRANCH_NAME}" | grep -q .; then
            REMOTE_COMMIT=$(git ls-remote bitbucket "${BRANCH_NAME}" | awk '{print $1}')
          fi
          
          # Check if bitbucket-pipelines.yml exists
          if [ -f "bitbucket-pipelines.yml" ]; then
            echo "pipelines_configured=true" >> $GITHUB_OUTPUT
          else
            echo "pipelines_configured=false" >> $GITHUB_OUTPUT
          fi
          
          # Check if commits match
          if [[ -n "$REMOTE_COMMIT" && "$CURRENT_COMMIT" == "$REMOTE_COMMIT" && "$FORCE_TRIGGER" != "true" ]]; then
            echo "Commits match ($CURRENT_COMMIT). Triggering pipeline via API..."
            echo "push_occurred=true" >> $GITHUB_OUTPUT
            echo "trigger_pipeline=true" >> $GITHUB_OUTPUT
            echo "branch_pushed=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          else
            # Different commit or force trigger or new branch
            echo "Pushing branch '${BRANCH_NAME}' to Bitbucket..."
            
            # Use --force to overwrite any divergent history on Bitbucket
            if output=$(git push --force bitbucket "HEAD:${BRANCH_NAME}" 2>&1); then
              echo "$output"
              echo "âœ… Branch '${BRANCH_NAME}' pushed to Bitbucket"
              echo "push_occurred=true" >> $GITHUB_OUTPUT
              echo "trigger_pipeline=false" >> $GITHUB_OUTPUT
              echo "branch_pushed=${BRANCH_NAME}" >> $GITHUB_OUTPUT
            else
              echo "$output"
              echo "âŒ Failed to push branch '${BRANCH_NAME}' to Bitbucket."
              
              if echo "$output" | grep -q "pre-receive hook declined"; then
                echo "::error::â›” PERMISSION DENIED: Bitbucket branch protection blocked the push."
                echo "ðŸ‘‰ SOLUTION: Go to Bitbucket Settings > Branching model > Branch permissions."
              else
                echo "=== Bitbucket / GitHub Divergence Detected ==="
                echo "GitHub commit: ${CURRENT_COMMIT}"
                echo "Bitbucket commit: ${REMOTE_COMMIT}"
                echo "::error::Divergence or other error detected. See logs above."
              fi
              exit 1
            fi
          fi

      - name: Trigger Bitbucket Pipeline (if needed)
        if: inputs.action_type != 'delete' && steps.mirror.outputs.trigger_pipeline == 'true'
        id: trigger-pipeline
        env:
          BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
          BITBUCKET_REPO: ${{ secrets.BITBUCKET_REPO }}
          BRANCH_NAME: ${{ inputs.branch_name }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          # Extract workspace and repo slug
          WORKSPACE=$(echo "$BITBUCKET_REPO" | cut -d'/' -f1)
          REPO_SLUG=$(echo "$BITBUCKET_REPO" | cut -d'/' -f2)
          
          echo "Triggering pipeline for branch: ${BRANCH_NAME}"
          
          # Trigger pipeline via API
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "https://api.bitbucket.org/2.0/repositories/${WORKSPACE}/${REPO_SLUG}/pipelines/" \
            -H "Authorization: Bearer ${BITBUCKET_API_TOKEN}" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -d "{\"target\": {\"ref_type\": \"branch\", \"type\": \"pipeline_ref_target\", \"ref_name\": \"${BRANCH_NAME}\"}}")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n -1)
          
          if [[ "$HTTP_CODE" -ge 200 && "$HTTP_CODE" -lt 300 ]]; then
            UUID=$(echo "$BODY" | grep -o '"uuid": *"[^"]*"' | head -1 | sed 's/"uuid": *"\([^"]*\)"/\1/' | tr -d '{}')
            if [ -n "$UUID" ]; then
              echo "âœ… Pipeline triggered via API (UUID: ${UUID})"
              echo "triggered_pipeline_uuid=${UUID}" >> $GITHUB_OUTPUT
            fi
          else
            echo "âš ï¸ Failed to trigger pipeline via branch ref, trying commit hash..."
            
            RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              "https://api.bitbucket.org/2.0/repositories/${WORKSPACE}/${REPO_SLUG}/pipelines/" \
              -H "Authorization: Bearer ${BITBUCKET_API_TOKEN}" \
              -H "Accept: application/json" \
              -H "Content-Type: application/json" \
              -d "{\"target\": {\"commit\": {\"hash\": \"${COMMIT_SHA}\"}, \"type\": \"pipeline_commit_target\"}}")
            
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n -1)
            
            if [[ "$HTTP_CODE" -ge 200 && "$HTTP_CODE" -lt 300 ]]; then
              UUID=$(echo "$BODY" | grep -o '"uuid": *"[^"]*"' | head -1 | sed 's/"uuid": *"\([^"]*\)"/\1/' | tr -d '{}')
              if [ -n "$UUID" ]; then
                echo "âœ… Pipeline triggered via commit hash (UUID: ${UUID})"
                echo "triggered_pipeline_uuid=${UUID}" >> $GITHUB_OUTPUT
              fi
            else
              echo "âŒ Failed to trigger pipeline via API"
              echo "$BODY"
            fi
          fi

      - name: Wait for Bitbucket Pipeline
        if: inputs.action_type != 'delete' && inputs.wait_for_pipeline && steps.mirror.outputs.pipelines_configured == 'true'
        id: wait-pipeline
        env:
          BITBUCKET_API_TOKEN: ${{ secrets.BITBUCKET_API_TOKEN }}
          BITBUCKET_REPO: ${{ secrets.BITBUCKET_REPO }}
          COMMIT_SHA: ${{ github.sha }}
          EXPECTED_PIPELINE_UUID: ${{ steps.mirror.outputs.triggered_pipeline_uuid || steps.trigger-pipeline.outputs.triggered_pipeline_uuid }}
          POLL_INTERVAL: ${{ inputs.poll_interval }}
          MAX_ATTEMPTS: ${{ inputs.max_attempts }}
        run: |
          WORKSPACE=$(echo "$BITBUCKET_REPO" | cut -d'/' -f1)
          REPO_SLUG=$(echo "$BITBUCKET_REPO" | cut -d'/' -f2)
          
          ATTEMPT=0
          FOUND_UUID=""
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            
            # Fetch pipelines for this commit
            RESPONSE=$(curl -s \
              "https://api.bitbucket.org/2.0/repositories/${WORKSPACE}/${REPO_SLUG}/pipelines/?pagelen=50&sort=-created_on&target.commit.hash=${COMMIT_SHA}" \
              -H "Authorization: Bearer ${BITBUCKET_API_TOKEN}" \
              -H "Accept: application/json")
            
            # Find the target pipeline
            if [ -n "$EXPECTED_PIPELINE_UUID" ]; then
              PIPELINE=$(echo "$RESPONSE" | jq -r ".values[] | select(.uuid | gsub(\"[{}]\"; \"\") == \"$EXPECTED_PIPELINE_UUID\") | @json" 2>/dev/null | head -1)
            else
              PIPELINE=$(echo "$RESPONSE" | jq -r '.values[0] | @json' 2>/dev/null)
            fi
            
            if [ -n "$PIPELINE" ] && [ "$PIPELINE" != "null" ]; then
              UUID=$(echo "$PIPELINE" | jq -r '.uuid' | tr -d '{}')
              STATE=$(echo "$PIPELINE" | jq -r '.state.name // empty')
              RESULT=$(echo "$PIPELINE" | jq -r '.state.result.name // empty')
              FOUND_UUID="$UUID"
              
              PIPELINE_URL="https://bitbucket.org/${WORKSPACE}/${REPO_SLUG}/addon/pipelines/home#!/results/${UUID}"
              
              echo "pipeline_uuid=${UUID}" >> $GITHUB_OUTPUT
              echo "pipeline_state=${STATE}" >> $GITHUB_OUTPUT
              echo "pipeline_result=${RESULT}" >> $GITHUB_OUTPUT
              echo "pipeline_url=${PIPELINE_URL}" >> $GITHUB_OUTPUT
              
              echo "[Attempt ${ATTEMPT}/${MAX_ATTEMPTS}] Pipeline ${UUID}: State=${STATE}, Result=${RESULT}"
              
              if [ "$STATE" = "COMPLETED" ]; then
                if [ "$RESULT" = "SUCCESSFUL" ]; then
                  echo "âœ… Bitbucket pipeline succeeded"
                  exit 0
                else
                  echo "âŒ Bitbucket pipeline failed: ${RESULT}"
                  echo "error_message=Pipeline failed with result: ${RESULT}. View: ${PIPELINE_URL}" >> $GITHUB_OUTPUT
                  exit 1
                fi
              fi
            else
              echo "[Attempt ${ATTEMPT}/${MAX_ATTEMPTS}] No pipeline found yet for commit ${COMMIT_SHA}..."
            fi
            
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              sleep $POLL_INTERVAL
            fi
          done
          
          echo "âŒ Timed out waiting for Bitbucket pipeline"
          if [ -n "$FOUND_UUID" ]; then
            echo "pipeline_url=https://bitbucket.org/${WORKSPACE}/${REPO_SLUG}/addon/pipelines/home#!/results/${FOUND_UUID}" >> $GITHUB_OUTPUT
          fi
          exit 1

      - name: Summarize Bitbucket pipeline result
        if: always()
        env:
          BB_PIPELINE_URL: ${{ steps.wait-pipeline.outputs.pipeline_url }}
          BB_PIPELINE_STATE: ${{ steps.wait-pipeline.outputs.pipeline_state }}
          BB_PIPELINE_RESULT: ${{ steps.wait-pipeline.outputs.pipeline_result }}
          BB_PIPELINE_ERROR: ${{ steps.wait-pipeline.outputs.error_message }}
        run: |
          echo "=== Bitbucket Pipeline Summary ==="
          
          if [ -n "$BB_PIPELINE_URL" ]; then
            echo "Pipeline URL: $BB_PIPELINE_URL"
          else
            echo "Pipeline URL: (not available)"
          fi
          
          if [ -n "$BB_PIPELINE_STATE" ]; then
            echo "Final state: $BB_PIPELINE_STATE"
          fi
          
          if [ -n "$BB_PIPELINE_RESULT" ]; then
            echo "Final result: $BB_PIPELINE_RESULT"
          fi
          
          if [ -n "$BB_PIPELINE_ERROR" ]; then
            echo ""
            echo "Bitbucket pipeline error details:"
            printf '%s\n' "$BB_PIPELINE_ERROR"
          fi

